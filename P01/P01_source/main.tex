\documentclass{article}
\usepackage[utf8]{inputenc}

% стилевой файл
\usepackage{NotesTeX_rus} 

\begin{document}

\begin{section}{Задача 1.}

\begin{center}
    \textbf{6. Проконтролировать, допускается ли инициализация переменных при описании; происходит ли инициализация по умолчанию.}
\end{center}

{\itshape 1. Введение в задачу.}\\
Во время объявления переменных можно сообщить им значение путем помещения знака равенства и константы после имени переменной. Этот процесс называется инициализацией и в общем случае имеет вид:
\begin{center}
тип имя\_переменной = константа;
\end{center}
Ниже приведено несколько примеров:
\begin{lstlisting}[language=C]
char c = 'a';
int number = 0;
float another_number = 123.23;
\end{lstlisting}

{\itshape 2. Постановка задачи.}\\
Требуется узнать, допускается ли инициализация переменных различных типов при их объявлении, в этом нетрудно убедиться непосредственной проверкой. Происходит ли инициализация по умолчанию выясним с помощью экспериментов.

{\itshape 3. Исследование задачи.}\\
Собственно, инициализация переменных действительно допускается при описании:
\includecode{p01_1.c}
Вот что выводится:\\
\includegraphics[scale = 0.6]{photo_1}
Теперь проверим, происходит ли инициализация по умолчанию:
\includecode{p01_2.c}
Вывод программы (с каждым выполнением разный результат):\\
\includegraphics[scale=0.6]{photo_2}
Общий вывод: неинициализированные переменные типа int и long по умолчанию принимают случайные значения, переменные типа char принимают значение null, а переменные типа float (или double) зануляются (компиляция проводилась под gcc).
\end{section}

\begin{section}{Задача 2.}
\begin{center}
    \textbf{18. Определите, каким образом при выполнении операции присваивания и явном приведении происходит преобразование беззнаковых целых (M-битовое представление) к беззнаковым целым (N-битовое представление) при M > N, M = N, M < N.}
\end{center}

{\itshape 1. Введение в задачу.}\\
Присваивание — механизм связывания в программировании, позволяющий динамически изменять связи имён объектов данных (как правило, переменных) с их значениями. Переменной отводится место в памяти - какое-то количество бит (ячеек), зависит от типа переменной. Типы соответственно бывают целые, символьные, вещественные и так далее, все они размещаются в памяти линейно, занимая определенное число бит.

{\itshape 2. Постановка задачи.}\\
Требуется узнать, что происходит с переменными в памяти после явного приведения типов, в данном случае при "расширении" или "урезании" отводимой для беззнаковой целочисленной переменной памяти. Это будет выяснено при помощи непосредственного побитового вывода.

{\itshape 3. Исследование задачи.}\\
Выведем содержимое ячеек памяти до и после непосредственного преобразования типов (используя написанные функции побитового вывода):
\includecode{p01_3.c}
Получаем следующий вывод:\\
\includegraphics[scale=0.6]{photo_3}
Нетрудно видеть, что при преобразовании из short в int новые биты заполняются нулями, при преобразовании из int в int ничего не меняется (действительно), при преобразовании из int в short первые 2 байта просто "обрубаются" (компиляция проводилась под gcc).
\end{section}

\end{document}
